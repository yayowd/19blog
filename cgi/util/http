#!/usr/bin/env bash

# This file is part of the 19blog project.
# 19blog is a simple blog site system.
# Copyright (C) 2020  The 19blog Authors.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# http common functions
# Dependent files:
#       no dependent
# NOTE: should be sourced once at any cgi interface
#       in order to ensure that the trap event is valid,
#       please sourced it first
# NOTE: all of functions must called in main shell,
#       and the result is $RET.
#       because error check in function,
#       and terminate response directly when error ocurse.

# --make response
#   $RESCODE+$RESHEAD+$RESBODY is all response buffer for one rquest
RESCODE=''
RESHEAD=''
RESBODY=''
# trap exit event to send response buffer
function onExit() {
    # clear the request post body first
    cat >/dev/null

    # ouput response buffer
    echo "$RESCODE"
    echo "$RESHEAD"
    echo -n "$RESBODY"
}
trap onExit EXIT
# set response code
#   $1  code
#   $2  descript
function resCode() {
    printf -v RESCODE 'HTTP/1.1 %s %s' "$1" "$2"
    RESHEAD=''
    RESBODY=''
}
# set response header
#   $1  name
#   $2  value
function resHead() {
    printf -v RESHEAD '%s%s: %s\n' "$RESHEAD" "$1" "$2"
}
# append reponse body
#   $1  text to append to reponse body
function resBody() {
    RESBODY=$RESBODY$1
}
# reponse 200
function res200() {
    resCode 200 'OK'
    resHead 'Content-Type' 'text/html; charset=UTF-8'
}
# response 301
#   $1  relocation url
function res301() {
    resCode 301 'Moved Permanently'
    resHead 'Location' "$1"
}
# response a html template file
# support var expand
#   $1  file path
function resFile() {
    if [ -z "$1" ]; then
        resErr 'File is empty when response a html template file.'
    fi

    # More difficult here
    # NOTE: 1.enclose sed parameter in single quotes to avoid bash string escaping
    #       2.the sed regular expression escaping
    #       3.it is very important to enclose the sed return value in double quotes
    #         It can avoid irregular individual garbled characters in multibyte strings
    html="$(sed 's/\(\\\)\([^$]\)/\1\1\2/g; s/"/\\"/g; s/`/\\`/g;' "$1")"
    # NOTE: 1.Escaping the eval command for the first time: the second parameter is expanded
    #       2.Escaping the resBody command for the second time: the first expanded parameter will be expanded again
    eval resBody "\"$html\""
}
# response error and terminate
#   $ERRCLOSE == true render close button on error screen
#   $ERRCLOSE == false render back button on error screen
function resErr() {
    htmlEncode "$*" && html=$RET

    if [ "$ERRCLOSE" = true ]; then
        errBtn="<a href='#' onclick='window.close()'>CLOSE</a>"
    else
        errBtn="<a href='#' onclick='history.back()'>BACK</a>"
    fi

    # set error msg as reponse body
    RESBODY="<div style='width=100%; height=100%; text-align: center;'> \
    <h4>ERROR</h4> \
    <p>$html</p> \
    <p>$errBtn</p> \
    </div>"

    # terminate response
    exit 1
}

# --html encoding
function htmlEncode() {
    RET=$(sed "s/\&/\&amp;/g; \
    s/</\&lt;/g; \
    s/>/\&gt;/g; \
    s/\"/\&quot;/g; \
    s/'/\&#39;/g" <<<"$*")
}
